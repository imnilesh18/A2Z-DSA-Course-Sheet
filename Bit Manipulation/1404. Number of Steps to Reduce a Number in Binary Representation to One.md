# 1404. Number of Steps to Reduce a Number in Binary Representation to One

<div align="center">
  <img src="https://img.shields.io/badge/LeetCode-Medium-yellow?style=for-the-badge&logo=leetcode" alt="Difficulty Badge"/>
  <img src="https://img.shields.io/badge/Bit%20Manipulation-blue?style=for-the-badge" alt="Tag Badge"/>
  <img src="https://img.shields.io/badge/String-green?style=for-the-badge" alt="Tag Badge"/>
</div>

## ğŸ”— Problem Link
[1404. Number of Steps to Reduce a Number in Binary Representation to One](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/)

## ğŸ“ Problem Statement
Given the binary representation of an integer as a string `s`, return the number of steps to reduce it to `1` under the following rules:

- If the current number is **even**, you have to divide it by `2`.
- If the current number is **odd**, you have to add `1` to it.

It is guaranteed that you can always reach one for all test cases.

## âš ï¸ Constraints
- `1 <= s.length <= 500`
- `s` consists of characters '0' or '1'
- `s[0] == '1'`

## ğŸ’¡ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `s = "1101"` | `6` | "1101" corresponds to number 13 in their decimal representation.<br>Step 1) 13 is odd, add 1 and obtain 14.<br>Step 2) 14 is even, divide by 2 and obtain 7.<br>Step 3) 7 is odd, add 1 and obtain 8.<br>Step 4) 8 is even, divide by 2 and obtain 4.<br>Step 5) 4 is even, divide by 2 and obtain 2.<br>Step 6) 2 is even, divide by 2 and obtain 1. |
| **2** | `s = "10"` | `1` | "10" corresponds to number 2 in their decimal representation.<br>Step 1) 2 is even, divide by 2 and obtain 1. |
| **3** | `s = "1"` | `0` | The number is already 1, so no steps are required. |

## ğŸš€ Approach

We have two main ways to solve this problem:

1. **Simulation (Brute Force):**
   We can directly apply the rules to the string. 
   - If the last digit of the string is '0' (the number is even), we just remove that '0' (this is equivalent to dividing by 2).
   - If the last digit is '1' (the number is odd), we add 1 to the string. To add 1, we traverse from right to left, changing all '1's to '0's until we find the first '0', and then change that '0' to '1'.

2. **Optimized (O(N)):**
   We don't need to modify the whole string repeatedly. We can scan the string from right to left (from index `n-1` down to `1`) and use a `carry` variable:
   - If the current bit + `carry` is odd, it means we have to add 1 (to make it even) and then divide by 2 (remove it). This takes exactly 2 operations, and our `carry` becomes 1.
   - If the current bit + `carry` is even, we can directly divide by 2. This takes only 1 operation.
   - Finally, for the 0th index, we just need to add the remaining `carry` to our total operations count.

## ğŸ’» Solution Code (Brute Force)

```cpp
// Intuition: The problem requires us to follow two rules based on the number being odd or even. We can simulate these rules directly on the binary string.
// Approach: Loop until the string length is greater than 1. If the last character is '0' (even), pop it (divide by 2). If '1' (odd), call addOne() which adds 1 to the binary string.
// Time Complexity: O(n^2) where n is the length of the string, as addOne can take O(n) in the worst case and we do it inside a loop.
// Space Complexity: O(1) as we are modifying the string in-place.
class Solution {
public:
    void addOne(string &s) {
        int i = s.length()-1;

        // Flip 1s to 0s from right to left
        while(i >= 0 && s[i] != '0') {
            s[i] = '0';
            i--;
        }

        // If all digits were 1, prepend 1
        if(i < 0) {
            s = '1' + s;
        } else {
            // Change the first found 0 to 1
            s[i] = '1';
        }
    }

    int numSteps(string s) {
        int op = 0;

        // Reduce until only '1' is left
        while(s.length() > 1) {
            int n = s.length();

            // If even, divide by 2 (remove last digit)
            if(s[n-1] == '0') {
                s.pop_back();
            } else {
                // If odd, add 1
                addOne(s);
            }

            op++;
        }

        return op;
    }
};

/*
*
* Dry Run
* s = "1101"
* op = 0
* Loop 1: s ends in '1'. addOne("1101") -> "1110". op = 1
* Loop 2: s ends in '0'. pop_back() -> "111". op = 2
* Loop 3: s ends in '1'. addOne("111") -> "1000". op = 3
* Loop 4: s ends in '0'. pop_back() -> "100". op = 4
* Loop 5: s ends in '0'. pop_back() -> "10". op = 5
* Loop 6: s ends in '0'. pop_back() -> "1". op = 6
* Loop ends as s.length() == 1.
* Return op (6).
*
*/

```

## ğŸ’» Solution Code (Optimized)

```cpp
// Intuition: An even bit requires 1 operation (divide by 2). An odd bit requires 2 operations (add 1, then divide by 2) and generates a carry.
// Approach: Traverse from right to left up to index 1. Keep track of 'carry'. For each bit, evaluate effective value = bit + carry. If effective value is 1 (odd), add 2 to ops and set carry to 1. If 0 or 2 (even), add 1 to ops. Finally, add the remaining carry.
// Time Complexity: O(n) where n is the length of the string, as we traverse it exactly once.
// Space Complexity: O(1) utilizing only primitive variables.
class Solution {
public:
    int numSteps(string s) {
        int n = s.length();

        int op = 0;
        int carry = 0;

        // Traverse from right up to the 1st index
        for(int i = n-1; i >= 1; i--) {
            // Check if effective bit is odd
            if(((s[i] - '0') + carry) % 2 == 1) { //odd
                op += 2;
                carry = 1;
            } else {
                // Effective bit is even
                op += 1;
            }
        }

        // Add remaining carry for the 0th bit
        return op + carry;
    }
};

/*
*
* Dry Run
* s = "1101"
* n = 4, op = 0, carry = 0
*
* i = 3: s[3] = '1'. Effective = 1 + 0 = 1 (odd).
* op = 2, carry = 1.
*
* i = 2: s[2] = '0'. Effective = 0 + 1 = 1 (odd).
* op = 2 + 2 = 4, carry = 1.
*
* i = 1: s[1] = '1'. Effective = 1 + 1 = 2 (even).
* op = 4 + 1 = 5, carry = 1.
*
* Loop ends. Return op + carry = 5 + 1 = 6.
*
*/

```

## ğŸ“ Notes

* The simulation method is easy to understand but can be slow (O(N^2)) for large strings.
* The mathematical method scans the string only once, making it much faster and highly memory-efficient.

## ğŸ’¡ Key Insights

* Any odd binary number always ends in `1`. Adding `1` to it and dividing by `2` takes a total of **2 operations**.
* Any even binary number ends in `0`. Dividing it by `2` takes only **1 operation** (just popping the '0').
* The `carry` variable helps us keep track of the effective value of a bit during the traversal.

## ğŸŒ Further Exploration

* Try solving this problem directly on integers using bitwise operations, when the given number easily fits within the 64-bit integer limit.
* Learn how carry propagation works internally in binary addition.

## ğŸ“š References

* [Bitwise Operations in C++](https://www.google.com/search?q=https://cplusplus.com/doc/tutorial/operators/)
* [LeetCode Discuss Section](https://www.google.com/search?q=https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/discuss/)

## ğŸ·ï¸ Tags

`String` `Bit Manipulation` `Math` `Simulation`

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)
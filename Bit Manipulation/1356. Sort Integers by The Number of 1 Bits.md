# 1356. Sort Integers by The Number of 1 Bits

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge&logo=leetcode" alt="Difficulty">
  <img src="https://img.shields.io/badge/Topics-Bit%20Manipulation,%20Sorting-blue?style=for-the-badge" alt="Tags">
</p>

## üìù Problem Statement

You are given an integer array `arr`. Sort the integers in the array in ascending order by the number of `1`'s in their binary representation. In case two or more integers have the same number of `1`'s, you have to sort them in ascending order.

Return the array after sorting it.

**Problem Link:** [Sort Integers by The Number of 1 Bits](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/)

### üéØ Examples

**Example 1:**
> **Input:** `arr = [0,1,2,3,4,5,6,7,8]`
> **Output:** `[0,1,2,4,8,3,5,6,7]`
> **Explanation:** > - `[0]` is the only integer with 0 bits.
> - `[1,2,4,8]` all have 1 bit.
> - `[3,5,6]` have 2 bits.
> - `[7]` has 3 bits.
> - The sorted array by bits is `[0,1,2,4,8,3,5,6,7]`

**Example 2:**
> **Input:** `arr = [1024,512,256,128,64,32,16,8,4,2,1]`
> **Output:** `[1,2,4,8,16,32,64,128,256,512,1024]`
> **Explanation:** All integers have 1 bit in the binary representation, you should just sort them in ascending order.

### üõë Constraints
- `1 <= arr.length <= 500`
- `0 <= arr[i] <= 10^4`

---

## üí° Explanation & Approach

The goal is to sort an array based on a specific property of the elements: the count of set bits (`1`s) in their binary form. 
If the set bit counts of two numbers are identical, we fall back to sorting them based on their actual integer values.

To achieve this, we can utilize a **custom comparator** (often written as a lambda function) that dictates how two elements `a` and `b` should be ordered.
1. Determine the number of `1` bits for `a` and `b`.
2. If the bit counts are the same, return `a < b` (to ensure ascending order by value).
3. If the bit counts differ, return `count_a < count_b` (to ensure ascending order by bit count).

**How do we count the set bits?**
1. **Manual Bit Manipulation (Brute Force / Concept Check):** We can iteratively perform an bitwise `AND` operation of the number with `1` (`num & 1`) to check if the right-most bit is a `1`. Then, right-shift the number (`num >>= 1`) and repeat until the number becomes `0`. This takes $O(\log(\text{num}))$ steps per number.
2. **Built-in Functions (Optimized):** Most modern languages provide built-in hardware-optimized operations. In C++, `__builtin_popcount()` returns the number of set bits in an integer in $O(1)$ constant time!

---

## üíª Solution Code

### Approach 1: Custom Function for Counting Bits

```cpp
// Intuition: We need to sort the array based on the number of set bits (1s). If two numbers have the same number of set bits, they should be sorted by their actual values. We can achieve this by writing a custom comparator for the standard sorting algorithm.
// Approach:
// 1. Create a helper function `countOneBits` that counts the number of 1s in the binary representation of a number by repeatedly checking the least significant bit (num & 1) and right-shifting the number.
// 2. Define a lambda function to act as a custom comparator.
// 3. Inside the lambda, find the bit counts for both numbers.
// 4. If the bit counts are equal, return `a < b` to sort by value. Otherwise, return `count_a < count_b` to sort by bit count.
// 5. Use the `sort` function with this lambda to sort the original array.
// Time Complexity: O(N log N * log(max_num)), where N is the length of the array. Sorting takes O(N log N) comparisons, and for each comparison, counting bits takes O(log(num)) time.
// Space Complexity: O(1) auxiliary space (excluding the recursion stack of the internal sorting algorithm).
class Solution {
public:
    int countOneBits(int num) {
        int count = 0;
        // Loop until all bits are processed
        while (num) {
            // Check if the last bit is 1 and add to count
            count += num & 1;
            // Right shift to process the next bit
            num >>= 1;
        }
        return count;
    }

    vector<int> sortByBits(vector<int>& arr) {
        // Lambda comparator to define sorting logic
        auto lambda = [&](int &a, int &b) {
            int count_a = countOneBits(a);
            int count_b = countOneBits(b);
            
            // If set bits are equal, sort by actual integer value
            if(count_a == count_b)
                return a < b;
            
            // Otherwise, sort by number of set bits
            return count_a < count_b;
        };
        
        // Apply the custom sort
        sort(begin(arr), end(arr), lambda);
        
        return arr;
    }
};

/*
*
* Dry Run
* Input: arr = [3, 8]
* Calling sort with lambda:
* Compare 3 and 8:
* countOneBits(3): 3 is 011 -> count = 2
* countOneBits(8): 8 is 1000 -> count = 1
* count_a (2) is not equal to count_b (1)
* Evaluate count_a < count_b -> 2 < 1 -> false
* Since it's false, 8 comes before 3.
* Sorted array: [8, 3]
*
*/
```

### Approach 2: Using Built-in function (Optimized)

```cpp
// Intuition: Instead of manually counting the bits which takes O(log(num)) time, we can use the compiler's highly optimized built-in function `__builtin_popcount` to get the set bits in O(1) time.
// Approach:
// 1. Define a lambda function for custom sorting.
// 2. Use `__builtin_popcount(x)` to get the number of 1s for both numbers in constant time.
// 3. If bit counts are identical, compare the actual values (a < b).
// 4. Otherwise, compare the bit counts (count_a < count_b).
// 5. Sort the array using this lambda.
// Time Complexity: O(N log N). __builtin_popcount calculates the number of set bits in constant time. So, overall time is dominated purely by the sorting algorithm.
// Space Complexity: O(1) auxiliary space (excluding the recursion stack of the internal sorting algorithm).
class Solution {
public:
    vector<int> sortByBits(vector<int>& arr) {
        // Lambda comparator utilizing built-in popcount
        auto lambda = [&](int &a, int &b) {
            // Get set bit count in O(1) time
            int count_a = __builtin_popcount(a);
            int count_b = __builtin_popcount(b);
            
            // Fallback to value comparison if bit counts match
            if(count_a == count_b)
                return a < b;
            
            // Sort primarily by bit count
            return count_a < count_b;
        };
        
        // Sort array in-place
        sort(begin(arr), end(arr), lambda);
        
        return arr;
    }
};

/*
*
* Dry Run
* Input: arr = [0, 1, 2]
* Compare 0 (bits: 0) and 1 (bits: 1) -> 0 < 1 -> true (0 comes first)
* Compare 1 (bits: 1) and 2 (bits: 1) -> bits are equal. Compare values: 1 < 2 -> true (1 comes before 2)
* Sorted array: [0, 1, 2]
*
*/
```

---

## üî¨ Key Insights
- Using a lambda expression with a capture clause `[&]` allows the custom comparator to seamlessly access out-of-scope variables if necessary, though in this optimized case, it keeps the logic clean and inline.
- Under the hood, built-in functions like `__builtin_popcount` map down to single hardware instructions on many architectures (like `POPCNT` in x86), reducing operation overhead dramatically.

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
# 1680. Concatenation of Consecutive Binary Numbers

![Difficulty: Medium](https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge&logo=leetcode)
![Tags: Math, Bit Manipulation](https://img.shields.io/badge/Tags-Math_%7C_Bit_Manipulation-blue?style=for-the-badge)

<br>

## üìú Problem Statement

Given an integer `n`, return the decimal value of the binary string formed by concatenating the binary representations of `1` to `n` in order, **modulo** `10^9 + 7`.

---

## üí° Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `n = 1` | `1` | "1" in binary corresponds to the decimal value 1. |
| **2** | `n = 3` | `27` | In binary, 1, 2, and 3 corresponds to "1", "10", and "11".<br>After concatenating them, we have "11011", which corresponds to the decimal value 27. |
| **3** | `n = 12` | `505379714` | The concatenation results in "1101110010111011110001001101010111100".<br>The decimal value of that is 118505380540.<br>After modulo 10^9 + 7, the result is 505379714. |

---

## ‚öôÔ∏è Constraints

- `1 <= n <= 10^5`

---

## üß† Approach

### The String Concatenation Trap (Brute-Force Concept)
A naive approach would be to convert every number from $1$ to $N$ into its binary string format, concatenate them all together, and then convert the massive binary string back into a decimal integer. However, given that $N$ can be up to $10^5$, this will result in a Time Limit Exceeded (TLE) error and consume too much memory.

### Bit Manipulation & Mathematical Shift (Optimized)
Instead of string conversions, we can achieve concatenation mathematically using bitwise operators.

1.  **Bit Shifting**: Suppose we have already calculated the concatenated value up to number $i-1$. To append the next number $i$, we need to make "room" for its binary representation.
2.  **Finding Room**: How much room do we need? Exactly the number of bits required to represent $i$. For example, $3$ is `11` in binary (2 bits). We can find this length using `log2(i) + 1`.
3.  **Left Shift & Add**: We take our current `result`, left-shift it by the required number of bits, and then add $i$ to it using the bitwise OR `|` or standard addition `+`.
    * *Formula*: `result = (result << bits) + i`
4.  **Modulo Arithmetic**: Since the intermediate values will exceed the limits of standard integer data types quickly, we must take the modulo $(10^9 + 7)$ after every shift and addition.

### Super Optimized Trick (Observing Power of 2)
Notice when the bit length of numbers increases:
- 1 requires **1 bit** (`1`)
- 2 requires **2 bits** (`10`) -> *Power of 2!*
- 3 requires **2 bits** (`11`)
- 4 requires **3 bits** (`100`) -> *Power of 2!*

The number of bits only increments when we encounter a power of 2. We can simply maintain a `digits` counter and increment it whenever `(i & (i - 1)) == 0`.

---

## üíª Solution Code

### Brute-Force / Standard Approach (Using `log2` function)

```cpp
// Intuition: We need to sequentially concatenate binary representations of numbers from 1 to n. Instead of manipulating strings, we can shift the current decimal result to the left by the number of bits of 'i', and add 'i'.
// Approach: 
// 1. Iterate from 1 to n.
// 2. Find the bit length of 'i' using log2(i) + 1.
// 3. Shift the accumulated result to the left by the calculated bit length.
// 4. Add the current number 'i' and take modulo 10^9 + 7 to prevent overflow.
// Time Complexity: O(N) where N is the given number. log2() is executed in O(1) via hardware level instructions.
// Space Complexity: O(1) as we are only using a few variables.

//Approach-1 (Using lo2(n) to find bits count)
//T.C : O(n)
//S.C : O(n)
class Solution {
public:
    int M = 1e9+7; // Modulo limit
    int concatenatedBinary(int n) {
        
        long result = 0; // Store the ongoing sequence calculation
        
        for(int i = 1; i<=n; i++) {
            int digits = log2(i) + 1; // Calculate required bits for current number
            
            // Left shift by digits, apply modulo, add i, and apply modulo again
            result = (((result << digits)%M) + i)%M;
        }
        
        return result; // Final calculated decimal value modulo 10^9 + 7
        
    }
};

/*
*
* Dry Run
* n = 3, M = 1e9+7
* * Initial: result = 0
* * Iteration 1 (i = 1):
* digits = log2(1) + 1 = 1
* result = ((0 << 1) % M + 1) % M = 1
* * Iteration 2 (i = 2):
* digits = log2(2) + 1 = 2
* result = ((1 << 2) % M + 2) % M = (4 + 2) % M = 6
* * Iteration 3 (i = 3):
* digits = log2(3) + 1 = 2
* result = ((6 << 2) % M + 3) % M = (24 + 3) % M = 27
* * Final Result: 27
*/

```

### Highly Optimized Approach (Checking Power of 2)

```cpp
// Intuition: The number of bits required to represent 'i' only increases when 'i' is a perfect power of 2. We can avoid calculating log2(i) on every iteration.
// Approach: 
// 1. Maintain a 'digits' variable to track current bit length.
// 2. Iterate from 1 to n. If 'i' is a power of 2 (i & (i - 1) == 0), increment 'digits'.
// 3. Shift the result left by 'digits' and add 'i', taking mod 1e9+7.
// Time Complexity: O(N) where N is the given number. Fast bitwise AND replaces the log2() function.
// Space Complexity: O(1) as it requires constant auxiliary space.

class Solution {
public:
    int concatenatedBinary(int n) {
        int M = 1e9 + 7; // Modulo limit
        long result = 0; // Store the ongoing sequence calculation
        int digits = 0;  // Track number of bits
        
        for(int i = 1; i <= n; i++) {
            // Check if 'i' is a power of 2
            if ((i & (i - 1)) == 0) {
                digits++; // Bit length increments at every power of 2
            }
            
            // Left shift by digits and add current number
            result = ((result << digits) + i) % M;
        }
        
        return result; // Final calculated decimal value
    }
};

/*
*
* Dry Run
* n = 3, M = 1e9+7
* * Initial: result = 0, digits = 0
* * Iteration 1 (i = 1):
* (1 & 0) == 0 -> true, digits becomes 1
* result = ((0 << 1) + 1) % M = 1
* * Iteration 2 (i = 2):
* (2 & 1) == 0 -> true, digits becomes 2
* result = ((1 << 2) + 2) % M = (4 + 2) % M = 6
* * Iteration 3 (i = 3):
* (3 & 2) == 2 != 0 -> false, digits remains 2
* result = ((6 << 2) + 3) % M = (24 + 3) % M = 27
* * Final Result: 27
*/

```

---

## üîé Key Insights

* **Why Bit Shifting?** Multiplying by $2^{\text{digits}}$ is mathematically identical to a left bitwise shift (`<< digits`). Shifting opens exactly the right number of $0$s on the right side of our accumulator to seamlessly add the bits of the next sequence number.
* **Power of Two Verification**: The bitwise trick `(x & (x - 1)) == 0` is extremely powerful for checking if a positive integer is a power of 2, making the code much faster without mathematical library calls like `log2`.
* **Distributive Property of Modulo**: Taking the modulo *after* every single operation (shift and addition) prevents 64-bit integer overflows, acting on the distributive property of modular arithmetic: $(A + B) \mod C = ((A \mod C) + (B \mod C)) \mod C$.

---

## üöÄ Further Exploration

* Explore how other mathematical functions can be optimized using Bitwise operations.
* Look into similar string-to-integer conversion problems on LeetCode without using native parsing methods.
* Consider exploring the `__builtin_clz()` function in C++ to count leading zeros to quickly determine the bit size of an integer!

---

## üîó References

* [Modulo Arithmetic Properties](https://www.google.com/search?q=https://en.wikipedia.org/wiki/Modular_arithmetic)
* [Bitwise Operations in C++](https://www.google.com/search?q=https://en.cppreference.com/w/cpp/language/operator_arithmetic)

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

* [imnilesh18](https://github.com/imnilesh18)
# 1461. Check If a String Contains All Binary Codes of Size K

![Difficulty: Medium](https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge&logo=leetcode)
![Language: C++](https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B)

## ğŸ“ Problem Statement

Given a binary string `s` and an integer `k`, return `true` if **every binary code** of length `k` is a substring of `s`. Otherwise, return `false`.

---

## âš™ï¸ Constraints

- `1 <= s.length <= 5 * 10^5`
- `s[i]` is either `'0'` or `'1'`.
- `1 <= k <= 20`

---

## ğŸ’¡ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **Example 1** | `s = "00110110"`, `k = 2` | `true` | The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indices 0, 1, 3 and 2 respectively. |
| **Example 2** | `s = "0110"`, `k = 1` | `true` | The binary codes of length 1 are "0" and "1", it is clear that both exist as a substring. |
| **Example 3** | `s = "0110"`, `k = 2` | `false` | The binary code "00" is of length 2 and does not exist in the string. |

---

## ğŸ§  Key Insights

1. **Total Possible Codes**: The number of all possible binary codes of length `k` is exactly $2^k$. (Example: for `k=2`, $2^2 = 4$ codes).
2. **Early Exit**: We don't have to scan the entire string. As soon as we find $2^k$ unique substrings, we can immediately return `true` without processing the rest of the string.
3. **Data Structure**: Using a hash set (`unordered_set`) is the most efficient way to keep track of unique substrings.

---

## ğŸš€ Approach

1. Calculate the total number of unique substrings needed, which is `1 << k` (equivalent to $2^k$).
2. Create an `unordered_set` to store and track unique substrings.
3. Loop through the string `s` and extract a substring of length `k` at each step.
4. If this substring is not already present in the set, insert it and decrement the required code count (`unique_sub`) by 1.
5. If at any point the required count reaches `0`, it means we have found all codes. Return `true` immediately (Early Return).
6. If the loop ends and the count is not 0, it means some codes are missing. Therefore, return `false`.

---

## ğŸ’» Solution Code

```cpp
// Intuition: For any given 'k', there are exactly 2^k possible binary codes. We can extract all substrings of length 'k' from the string 's' and store them in a set. If the count of unique substrings reaches 2^k, the answer is true.
// Approach: 
// 1. Calculate the total required unique substrings (2^k).
// 2. Use an unordered_set to track unique substrings.
// 3. Loop through the string 's' and extract substrings of length 'k'.
// 4. If a substring is not in the set, insert it and decrement the required count.
// 5. If the count reaches 0, return true (early exit).
// 6. If the loop finishes and the count is not 0, return false.
// Time Complexity: O(N * K), where N is the length of string 's'. Extracting a substring of length 'K' takes O(K) time.
// Space Complexity: O(2^K * K), to store at most 2^K substrings (each of length K) inside the set.

class Solution {
public:
    bool hasAllCodes(string s, int k) {
        // Set to store unique substrings
        unordered_set<string> st;
        
        int n = s.length();
        // There should be exactly 2^k unique substrings (1 << k means 2^k)
        int unique_sub = 1 << k; 
            
        // Start from i = k so we can safely extract substring of length k from i-k
        for(int i = k; i <= n; i++) {
            // Extract substring of length k
            string a = s.substr(i - k, k);
            
            // If substring is not already present in the set
            if(!st.count(a)) {
                st.insert(a);
                unique_sub--; // Decrement the count of required substrings
                
                // If all required substrings are found, early exit
                if(unique_sub == 0)
                    return true;
            }
        }
        
        // If all possible codes were not found
        return false;
    }
};

/*
*
* Dry Run
*
* Input: s = "0110", k = 1
* n = 4, unique_sub = 1 << 1 = 2
*
* Iteration 1 (i = 1):
* a = s.substr(0, 1) = "0"
* "0" is not in st -> st.insert("0"), unique_sub = 1
* unique_sub (1) != 0
* * Iteration 2 (i = 2):
* a = s.substr(1, 1) = "1"
* "1" is not in st -> st.insert("1"), unique_sub = 0
* unique_sub == 0 -> return true
*
* Output: true
*
*/
```

---

## ğŸ” Further Exploration
If the string size and `k` are very large, you can optimize space and time further using a **Rolling Hash** or **Bit Manipulation** approach to avoid the overhead of continuous string extraction. 

## ğŸ·ï¸ Tags
`Hash Table`, `String`, `Bit Manipulation`, `Rolling Hash`

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)
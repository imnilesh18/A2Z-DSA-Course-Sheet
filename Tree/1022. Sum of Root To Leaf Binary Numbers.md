# 1022. Sum of Root To Leaf Binary Numbers

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="Tree Diagram" />
</div>

## ğŸŸ¢ Difficulty: Easy
**Tags:** `Tree`, `Depth-First Search`, `Binary Tree`

---

## ğŸ“ Problem Statement

You are given the `root` of a binary tree where each node has a value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit.

For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return **the sum of these numbers**.

> **Note:** The test cases are generated so that the answer fits in a `32-bits` integer.

---

## ğŸ’¡ Examples

### Example 1:
| Input | Output |
| :--- | :--- |
| `root = [1,0,1,0,1,0,1]` | `22` |

<details>
<summary><b>View Explanation</b></summary>

There are 4 root-to-leaf paths:
- Path 1: `1 -> 0 -> 0` = Binary `100` = `4`
- Path 2: `1 -> 0 -> 1` = Binary `101` = `5`
- Path 3: `1 -> 1 -> 0` = Binary `110` = `6`
- Path 4: `1 -> 1 -> 1` = Binary `111` = `7`

Total Sum: `4 + 5 + 6 + 7 = 22`
</details>

### Example 2:
| Input | Output |
| :--- | :--- |
| `root = [0]` | `0` |

---

## âš™ï¸ Constraints

- The number of nodes in the tree is in the range `[1, 1000]`.
- `Node.val` is `0` or `1`.

---

## ğŸ§  Approach

We will use **Depth-First Search (DFS)** or Recursion to solve this problem. This is the most optimized approach as it traverses the tree only once:

1. **Keep Track of State:** Start from the root and maintain a current `val` initialized to `0`.
2. **Left Shift Operation:** Every time we move down a node, we multiply the existing value by `2` (which is equivalent to a bitwise left shift in binary) and add the current node's value.
   *Formula: `val = (2 * val) + root->val`*
3. **Base Case:** If the current node is a leaf node (meaning it has no left or right child), simply return the computed `val`.
4. **Recursive Call:** If it is not a leaf node, recursively call the DFS function on the left and right children, and return the sum of the results from both sides.
5. **Null Node:** If the node is `NULL`, return `0`.

---

## ğŸ’» Solution Code

### Optimized Solution

```cpp
// Intuition: As we traverse down a binary tree, each new digit shifts the previously accumulated binary number to the left by one position (which is equivalent to multiplying by 2). We can use this mathematical property to extract the path value.
// Approach: 
// 1. Use Depth-First Search (DFS) starting from the root with an initial value of 0.
// 2. At each node, update the current value by multiplying it by 2 (left shift) and adding the node's value.
// 3. If a leaf node is reached, return the accumulated value.
// 4. Otherwise, recursively compute the sum for the left and right subtrees and return their total.
// Time Complexity: O(N), where N is the total number of nodes in the tree, because we visit each node exactly once.
// Space Complexity: O(H), where H is the height of the tree, representing the recursion stack space. In the worst case (skewed tree), it can be O(N). For a balanced tree, it will be O(log N).

class Solution {
public:
    int solve(TreeNode* root, int val) {
        // Base condition: if the node is null, return 0
        if(!root) { // root == NULL
            return 0;
        }

        // Multiply the current value by 2 and add the current bit
        val = (2 * val) + root->val;

        // If it's a leaf node (no left or right child), return the derived value
        if(root->left == NULL && root->right == NULL) {
            return val;
        }

        // Return the sum of the results from the left and right subtrees
        return solve(root->left, val) + solve(root->right, val);
    }

    int sumRootToLeaf(TreeNode* root) {
        // Start the recursion with an initial value of 0
        return solve(root, 0);
    }
};

/*
*
* Dry Run
*
* Tree: [1, 0, 1]
* 1. sumRootToLeaf(root) -> calls solve(Node 1, 0)
* 2. solve(Node 1, 0):
* - val = (2 * 0) + 1 = 1
* - Not a leaf, so return solve(left, 1) + solve(right, 1)
* 3. solve(Node 0, 1) (Left Child):
* - val = (2 * 1) + 0 = 2
* - It is a leaf, return 2.
* 4. solve(Node 1, 1) (Right Child):
* - val = (2 * 1) + 1 = 3
* - It is a leaf, return 3.
* 5. Back to Node 1: return 2 + 3 = 5.
* Final Output: 5
*
*/
```

---

## ğŸ—’ï¸ Notes
- This approach is highly efficient as it operates directly on numbers using basic arithmetic rather than storing and converting strings or arrays.

## ğŸ” Key Insights
- **Binary Arithmetic:** Appending a new digit to the right of any binary number simply means multiplying the old number by `2` and adding the new digit. 
- **Leap of Faith in Recursion:** In tree problems, recursion is a very powerful and simple tool. We only need to write the logic for a single node and trust that the recursive calls will handle the children correctly.

## ğŸš€ Further Exploration
- To make this code even more concise, you can use **Bitwise Operators**. The operation `(2 * val)` can be replaced with `(val << 1)` which is slightly faster at the machine level.
- Try solving this problem iteratively using **Breadth-First Search (BFS)** with a queue to store both the node and the ongoing path value.

## ğŸ”— References
- [LeetCode Problem 1022 - Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)
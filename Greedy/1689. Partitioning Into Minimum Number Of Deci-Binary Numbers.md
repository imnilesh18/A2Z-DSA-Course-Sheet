# 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-fd8c00?style=for-the-badge&logo=leetcode" alt="Difficulty Medium"/>
  <img src="https://img.shields.io/badge/String-blue?style=for-the-badge" alt="Tag String"/>
  <img src="https://img.shields.io/badge/Greedy-green?style=for-the-badge" alt="Tag Greedy"/>
  <img src="https://img.shields.io/badge/Math-purple?style=for-the-badge" alt="Tag Math"/>
</p>

## ğŸ“ Problem Statement

A decimal number is called **deci-binary** if each of its digits is either `0` or `1` without any leading zeros. For example, `101` and `1100` are deci-binary, while `112` and `3001` are not.

Given a string `n` that represents a positive decimal integer, return *the **minimum** number of positive deci-binary numbers needed so that they sum up to `n`*.

### ğŸ”— Problem Link
[1689. Partitioning Into Minimum Number Of Deci-Binary Numbers](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/description/)

---

## ğŸš€ Examples

| Example | Input | Output | Explanation |
| :--- | :--- | :--- | :--- |
| **1** | `n = "32"` | `3` | `10 + 11 + 11 = 32` |
| **2** | `n = "82734"` | `8` | The maximum digit is 8, so we need 8 numbers. |
| **3** | `n = "27346209830709182346"` | `9` | The maximum digit is 9, so we need 9 numbers. |

---

## ğŸ›‘ Constraints

- `1 <= n.length <= 10^5`
- `n` consists of only digits.
- `n` does not contain any leading zeros and represents a positive integer.

---

## ğŸ§  Approach & Explanation

If we look at the core of the problem, a deci-binary number can only contribute a maximum of `1` to any digit of our target sum at a time. 

Consider an example target number: `32`.
- To form the digit `3` in the tens place, we absolutely must add `1` three times. 
- To form the digit `2` in the ones place, we need to add `1` two times. 

Therefore, if we build our deci-binary numbers optimally by placing `1`s wherever the remaining digit is greater than `0`, the number of deci-binary numbers required will simply fall back to the **largest digit present** in the given string `n`. 

### 1. Simulation (Brute Force) Approach
We can simulate this process by looping over the string `n`. During each pass, we subtract `1` from any non-zero digit. The number of passes it takes for all digits to become `0` is our answer. While this method simulates the problem properly, it helps to build up the intuition for the optimal trick.

### 2. Optimized Approach (The Trick)
Based on our observation, the entire process takes exactly as many steps as the maximum digit in the input. Therefore, we can bypass the simulation entirely and simply return the maximum character found in the string `n`, converting it back to an integer.

---

## ğŸ’» Solution Code

### ğŸŒ Brute-force / Simulation Solution (C++)

```cpp
// Intuition: We can simulate the process of subtracting a deci-binary number by decreasing every non-zero digit by 1. The number of passes required to make all digits zero will be our answer.
// Approach: Run an infinite loop. In each iteration, traverse the string and decrement every character that is not '0'. If no characters were decremented in a pass, break the loop. Otherwise, increment the count.
// Time Complexity: O(n * D), where n is the length of the string and D is the maximum digit (which can be <= 9). This simplifies to roughly O(n).
// Space Complexity: O(1), as we modify the input string in-place without using extra memory.
class Solution {
public:
    int minPartitions(string n) {
        int count = 0;

        while (true) {
            bool changed = false; // Flag to track if any digit was reduced

            for (char &ch : n) {
                if (ch != '0') {
                    ch--;          // subtract 1
                    changed = true; // mark that a change occurred
                }
            }

            if (!changed) // If no digits changed, string is all '0's
                break;

            count++; // Increment the required deci-binary numbers count
        }

        return count;
    }
};

/*
*
* Dry Run
* Input: n = "32"
*
* Pass 1:
* '3' becomes '2', '2' becomes '1' -> string is "21", count = 1
*
* Pass 2:
* '2' becomes '1', '1' becomes '0' -> string is "10", count = 2
*
* Pass 3:
* '1' becomes '0', '0' remains '0' -> string is "00", count = 3
*
* Pass 4:
* No changes occur. Break loop.
*
* Final Output: 3
*
*/

```

### ğŸš€ Optimized Solution (C++)

```cpp
// Intuition: The maximum digit in the number dictates the minimum number of deci-binary numbers needed. For example, to get a '9', we need at least nine '1's.
// Approach: Find the maximum character in the string using `max_element`. Convert this character to its integer value by subtracting '0'.
// Time Complexity: O(n), where n is the length of the string. We iterate through the string exactly once to find the maximum element.
// Space Complexity: O(1), as we only need a few variables for computation and no extra data structures are used.
class Solution {
public:
    int minPartitions(string n) {
        // Find the maximum char and convert it to its integer equivalent
        return *max_element(begin(n), end(n)) - '0';
    }
};

/*
*
* Dry Run
* Input: n = "82734"
*
* Step 1: max_element traverses "82734" and finds '8' as the max char.
* Step 2: Extract the char '8'.
* Step 3: Compute '8' - '0' to convert character to integer 8.
*
* Final Output: 8
*
*/

```

---

## ğŸ’¡ Key Insights

* Always look at the core requirements. Many medium or hard problems involving digit manipulations can be narrowed down to identifying boundaries (like the maximum digit).
* String traversal algorithms in C++ like `max_element` keep code clean, optimized, and incredibly succinct.

## ğŸ“š Further Exploration

* Explore how deci-binary arrays can be generated dynamically if the problem instead asked to *print* all the components making up the sum.

## ğŸ·ï¸ Tags

`String` `Greedy` `Math` `Simulation`

---

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/description/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

* [imnilesh18](https://github.com/imnilesh18)